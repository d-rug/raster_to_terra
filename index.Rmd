---
title: Raster to Terra
author: Elise Hellwig
date: "`r Sys.Date()`"

github-repo: d-rug/raster_to_terra
url: "https://d-rug.github.io/raster_to_terra/"

site: "bookdown::bookdown_site"
knit: "bookdown::render_book"
output:
  bookdown::gitbook:
    config:
      toc:
        before: |
          <li><a href="https://d-rug.github.io/">
            <img src="https://github.com/d-rug/d-rug.github.io/raw/main/DRUG_final_cobalt.png" style="height: 100%; width: 100%; object-fit: contain" />
          </a></li>
          <li><a href="./" style="font-size: 18px">Raster to Terra</a></li>
        after: |
          <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">
            <img alt="CC BY-SA 4.0" src="https://img.shields.io/badge/License-CC%20BY--NC--SA%204.0-lightgrey.svg" style="float: right; padding-right: 10px;" />
          </a>
        collapse: section
      sharing: no
      view: https://github.com/d-rug/raster-to-terra/blob/main/%s
      edit: https://github.com/d-rug/raster-to-terra/edit/main/%s
---

# Overview {-}

No one wants to relearn something they already know how to do. But sometimes 
there's no other choice. The sp, rgdal, rgeos, and maptools packages will be
[gone by the end of 2023](https://r-spatial.org/r/2023/05/15/evolution4.html).
The raster package is not long for this world [either](https://rspatial.org/raster/).
sf is nice, but it doesn't have the raster functionality necessary for many
types of analysis. This workshop aims to make the transition from raster to
terra as painless as possible. 

Each of this workshop will have a conversion table. This table will tell you 
which `terra` function to use, given an operation and data type. It will also
provide the functions from `raster`, `sp`,  `rgdal`, and `rgeos` that used to 
accomplish that operation.

## Learning Goals

- Get a sense for the functionality of the terra package as a whole
- Be able to translate existing code from deprecated packages to terra syntax
- Know where to find more information about `terra`.

**This presentation will NOT give you a comprehensive discussion of `terra`.**

It is too short for that. However, it will provide links to places you can find 
more documentation.

## Prerequisites

- Familiarity with the raster and sp packages 

## What we will cover

 - read/write
 - transformations
 - joining
 - calculations
 - get coordinates for spatVector
 - sampling
 - transformation
 - Plotting
 - interpolation
 - data access

# `terra`: a bird's eye view

 - The last spatial package you'll ever need*
 - Rasters and Vectors, with united functions where possible
 - One task, one function
 - Improved speed
 - Very large: 345 functions; raster has 277, sf has 150
 - Some things changed, many stayed the same
 
Old Packages: sp, raster, rgdal, rgeos, maptools

New Packages: terra and geodata (for data)


```{r setup, message=FALSE, warning=FALSE}

library(microbenchmark) # for speed testing

#new packages
library(terra) 
library(geodata)

#old packages
library(raster)
library(rgdal)

#table formatting
library(data.table)
library(kableExtra)
library(scales)

options(warn=-1)

elev_fn = system.file("ex/elev.tif", package="terra")
lux_fn = system.file("ex/lux.shp", package="terra")

elev = rast(elev_fn)
r_elev = raster(elev)

lux = vect(lux_fn)
sp_lux = shapefile(lux_fn)

```


```{r table_setup, echo=FALSE}

n_reps = 10

funs = fread('raster_to_terra_funs.csv')

vars = c('Operation', 'DataType', 'old', 'terra')

col_names = c('Operation', 'Data Type', 'Old Functions', 'New Functions')

time_to_power = function(nano) {
  return(floor(log(nano, 10)))
}

microbench_df = function(mb, labs=NA) {
  
  mb2 <- copy(mb)
  setDT(mb2)
  
  sec_types = rep(c('nano', 'micro','milli', ''), each=3)
  
  n = dim(mb2)[1]/length(levels(mb2$expr))
  
  if (!is.na(labs[1])){
    mb2[,expr:=factor(expr, labels=labs)]
    
  }  
  
  mb_tab = mb2[,.(median=median(time),
                  n_eval=n,
                  id=as.integer(expr)),
               by=expr]
  
  setkey(mb_tab, id)
  
  mb_tab$id <- NULL
  
  unit_pwr = time_to_power(min(mb_tab$median))
  
  num_format = label_comma(accuracy=0.01, scale=10^(-unit_pwr))
  
  mb_tab[,median:=num_format(median)]
  
  setnames(mb_tab, 
           c('expr', 'median'),
           c('function', paste0('median (', sec_types[unit_pwr+1],'sec)'))
           )
  
  return(mb_tab)
  
}


```


# The basics

## Reading in data

Reading and writing data functionality is based on GDAL, so you will have all 
the flexibility in your choice of file type that GDAL provides. 

```{r io_table, echo=FALSE}

io = funs[OperationGroup=='I/O', ..vars]

io %>% 
  kbl(col.names = col_names) %>% 
  kable_styling()

```




```{r read_raster_bench}

# reading data 

readbench = microbenchmark(
  rast(elev_fn),
  raster(elev_fn),
  vect(lux_fn),
  shapefile(lux_fn),
  readOGR(lux_fn, verbose = FALSE),
  
  times = n_reps
)

read_names = c('terra::rast', 'raster::raster', 'terra::vect', 'raster::shapefile',
               'rgdal::readOGR')

readtab = microbench_df(readbench, read_names)

readtab %>% 
  kbl(align='lrr') %>% 
  kable_styling()


```


## Writing data

The function `writeRaster()` is relatively unchanged, though the argument 
specifying the type of file written has changed from `format` (in `raster`) to 
`filetype` (in `terra`). Additionally, while in theory the function can 
automatically detect the file type, it seems to rarely work, so it is better to 
just specify `filetype` from the get-go. 

With `spatVectors` we get `writeVector()`, which largely mirrors `writeRaster()`.

```{r write_raster}


# writing data 

writebench = microbenchmark(
  terra::writeRaster(elev,
                     filename='data/elevation.GTiff',
                     filetype='GTiff', 
                     overwrite=TRUE),
  raster::writeRaster(r_elev,
                      filename='data/elevation.GTiff',
                      format='GTiff',
                      overwrite=TRUE),
  writeVector(lux, 
              filename='data/lux.shp', 
              overwrite=TRUE),
  shapefile(sp_lux, 
            filename='data/lux.shp', 
            overwrite=TRUE),
  writeOGR(sp_lux,
          dsn='data/lux.shp',
          layer='lux',
          driver='ESRI Shapefile',
          overwrite_layer=TRUE,
          verbose=FALSE),
  
  times = n_reps
)

write_names = c('terra::writeRaster', 'raster::writeRaster', 'terra::writeVector',
                'raster::shapefile', 'rgdal::writeOGR')

write_tab = microbench_df(writebench, write_names)

write_tab %>% 
  kbl(align='lrr') %>% 
  kable_styling()

```



```{r write_vect}

microbenchmark(
  writeVector(lux, 
            filename='data/lux.shp', 
            overwrite=TRUE),
  shapefile(sp_lux, 
            filename='data/lux.shp', 
            overwrite=TRUE),
  
  times = 100
)


```


# Transform

```{r transform_table, echo=FALSE}

trans_tab = funs[OperationGroup=='Transform', ..vars]

trans_tab %>% 
  kbl(col.names = col_names) %>% 
  kable_styling()

```

Most of the methods for transforming spatial data remain the same from raster.
The exception to that is `raster::projectRaster()`, which now becomes 
`terra::project()` and now works for both rasters and vectors. 

```{r project_raster_bench}

microbenchmark(
  terra::project(elev, "epsg:3310"),
  raster::projectRaster(r_elev, crs="epsg:3310"),
  
  times=10
)


```

# Calculate

## Summary
One of `raster`'s claims to fame was the ease at which you could do calculations.
R automatically treated each cell in a `RasterLayer` as if it was a number, and 
each cell in a `RasterBrick` or `RasterStack` as if it were a vector. There are
additional functions for doing calculations on an entire layer of a raster and 
for applying non-vectorized functions.

## Conversion Table

```{r calculate_table, echo=FALSE}

calc_tab = funs[OperationGroup=='Calculate', ..vars]

calc_tab %>% 
  kbl(col.names = col_names) %>% 
  kable_styling()

```

# Combine

## Querying 

Similar to 

# Extents



# What about sf (and stars)?
