[["index.html", "Raster to Terra Overview Learning Goals Prerequisites What we will cover Setup", " Raster to Terra Elise Hellwig 2023-12-22 Overview No one wants to relearn something they already know how to do. But sometimes there’s no other choice. The rgdal, rgeos, and maptools packages have been officially retired, and sp is only available for legacy reasons as a wrapper around sf. The raster package is not long for this world either. sf is nice, but it doesn’t have the raster functionality necessary for many types of analysis. This reader aims to make the transition from raster to terra as painless as possible. Additionally, because both raster an terra are so large, this reader focuses on things that have changed between raster and terra. If you don’t see something mentioned here, that doesn’t mean it doesn’t exist in terra. It probably just didn’t change between the two packages. Learning Goals Get a sense for the functionality of the terra package as a whole Be able to translate existing code from deprecated packages to terra syntax Know where to find more information about terra. This reader will NOT give you a comprehensive tour of terra. It is too short for that. However, it will provide links to places you can find more documentation. Prerequisites Familiarity with the raster and sp packages What we will cover Package overview New classes and object creation Method name changes Spatial relationships Calculations Plotting What’s not in terra Setup library(microbenchmark) # for speed testing #new packages library(terra) library(geodata) library(tidyterra) library(sf) #old packages library(raster) library(rgdal) #formatting library(data.table) library(kableExtra) library(scales) library(RColorBrewer) temp_pal = colorRampPalette(brewer.pal(9, &#39;YlOrRd&#39;))(50) precip_pal = colorRampPalette(brewer.pal(9, &#39;Blues&#39;))(50) geodata_path(&#39;data/&#39;) cv = function(x, na.rm=TRUE) sd(x, na.rm=na.rm)/mean(x, na.rm=na.rm) options(warn=-1) elev_fn = system.file(&quot;ex/elev.tif&quot;, package=&quot;terra&quot;) lux_fn = system.file(&quot;ex/lux.shp&quot;, package=&quot;terra&quot;) elev = rast(elev_fn) r_elev = raster(elev) lux = vect(lux_fn) sp_lux = shapefile(lux_fn) temp = worldclim_country(country=&#39;LUX&#39;, var=&#39;tavg&#39;) precip = worldclim_country(country=&#39;LUX&#39;, var=&#39;prec&#39;) names(temp) = month.name names(precip) = month.name "],["the-basics.html", "1 The Basics 1.1 A bird’s eye view 1.2 Classes 1.3 Reading in data 1.4 Writing data", " 1 The Basics This section covers an overview of the terra package, as well as the basics for getting geospatial data in and out of R using terra. 1.1 A bird’s eye view The terra package looks like what would happen if the authors of raster got frustrated with maintaining a package whose scope had ballooned massively over its 10+ year history, and decided to start from scratch to create a newer, better geospatial package. Because that is in fact what happened. Terra in a nutshell: Raster AND vector support Fewer classes, more functionality One task, one function Written in C++ for improved speed Very large: 345 functions; raster has 277, sf has 150 Some things changed, many stayed the same Old Packages: sp, raster, rgdal, rgeos, maptools New Packages: terra, geodata, and tidyterra (for plotting) 1.2 Classes The terra package condenses the number of classes necessary for analysis from 10 down to 3: one for rasters, one for vectors, and one for extents. 1.3 Reading in data The raster constructor method, rast, changed quite a bit from raster, at least in part because it is a combination of three previous functions: raster, brick and stack. Most of the existing arguments are renamed, and some new ones added, including the ability to specify a timestamp and units for each layer of an empty raster. Additionally rast and vect, the vector constructor method, provide data filtering built in. They both allow layer selection and spatial filtering and vect allows SQL queries from spatial databases as well. #import elevation data for Luxembourg elev = rast(elev_fn, , lyrs=1) #import polygons for cantons of the district of Diekirch lux = vect(lux_fn) Terra speeds up reading in both raster an vector data. This is due to C++ implementation of the classes, which imposes some limitations. Most significantly for reading in data, spatRasters and spatVectors cannnot be recovered from a saved R session. However, using saved R sessions is not a good (reproducible) practice anyway, so consider this a feature not a bug. Reading and writing data functionality is still based on GDAL, so you will have all the flexibility in your choice of file type that GDAL provides, but will have to deal with the issues that using GDAL generates. 1.3.1 Reading Speed Improvements function median (millisec) n_eval terra::rast() 1.09 100 raster::raster() 6.58 100 terra::vect() 1.18 100 sf::st_read() 1.31 100 raster::shapefile() 15.96 100 rgdal::readOGR() 866.02 100 1.4 Writing data The function writeRaster is relatively unchanged, though the argument specifying the type of file written has changed from format (in raster) to filetype (in terra). Additionally, while in theory the function can automatically detect the file type, it seems to rarely work, so it is better to just specify filetype from the get-go. For spatVectors we get writeVector, which largely mirrors writeRaster. writeRaster(elev, filename=&#39;data/elevation.GTiff&#39;, filetype=&#39;GTiff&#39;, overwrite=TRUE) writeVector(lux, filename=&#39;data/lux.GeoJSON&#39;, filetype=&#39;GeoJSON&#39;, overwrite=TRUE) 1.4.1 Writing Speed Improvements function median (millisec) n_eval terra::writeRaster 3.33 100 raster::writeRaster 28.55 100 terra::writeVector 1.45 100 sf::st_write 8.09 100 raster::shapefile 4.53 100 rgdal::writeOGR 3.66 100 "],["working-with-data.html", "2 Working with Data 2.1 Renamed Methods 2.2 Combined Methods 2.3 Speed Improvements 2.4 Spatial Relationships", " 2 Working with Data This section covers changes made to common data manipulation and querying methods. 2.1 Renamed Methods In general, when method names were changed in terra, they got shorter and more similar to base R. Most capital letters were removed as well. Old Methods New Method coordinates crds getValues values nlayers nlyr reclassify, subs, cut classify stack, addLayer c unstack as.list dropLayer subset rasterTo* as.* isLonLat is.lonlat bind rbind 2.2 Combined Methods Many tasks that previously at separate methods for raster and vector data, due to the classes originating in separate packages, now have shared method names. Functions in green rows have been renamed, while functions in grey rows, maintain their name from raster. Operation Old Methods New Method reproject geometry projectRaster, sp::spTransform project combine cells/polygons aggregate aggregate split cells/polygons disaggregate disagg spatial query extract, sp::over extract spatial sampling sp::spsample, sampleRandom spatSample 2.3 Speed Improvements Many of the most time-intensive operations got speed boosts from the C++ implementation. function median (millisec) n_eval terra::spatSample 2.15 100 raster::sampleRandom 6.59 100 terra::project 34.54 100 raster::projectRaster 58.91 100 terra::resample 1.86 100 raster::resample 51.63 100 terra::rasterize 1.80 100 raster::rasterize 252.48 100 terra::as.polygons 27.72 100 raster::rasterToPolygons 221.18 100 2.4 Spatial Relationships A key function in any GIS software is the ability to determine the relationship between two spatial objects. Previous packages (raster, rgeos) used used different method names depending on the geometric query in question. Rgeos in particular contained at least twelve functions just for determining spatial relationship. In terra, the number of objects compared (not the relationship type) determines the function used. For one-to-one and one-to-many comparisons use is.related(), for many-to-many comparisons, use relate(). The relation argument specifies relationship type. Options include intersects, touches, crosses, overlaps, within, contains, covers, covered by, disjoint, or DE-9IM strings. #is our raster big enough to cover all of Luxembourg is.related(elev, lux, relation=&#39;covers&#39;) ## [1] TRUE Method names for the spatial operations below remain unchanged: union() intersect() symdif() buffer() crop() cover() mask() "],["calculations.html", "3 Calculations 3.1 Raster Math 3.2 Spatial Calculations 3.3 Local (*app) Functions 3.4 Applying Deep Dive", " 3 Calculations This section covers various methods for doing calculations with spatRasters. 3.1 Raster Math One of raster’s claims to fame was the ease at which you could do calculations. R automatically treated each cell in a RasterLayer as if it was a number, and each cell in a RasterBrick or RasterStack as if it were a vector. There were additional functions for doing calculations on an entire layer of a raster and for applying non-vectorized functions. Raster arithmetic and math are still very easy with spatRasters. In fact, many statistical summary functions are pre-vectorized for spatRasters, so if you want to apply them by cell, you don’t even need to use a vectorizing function like app. #average annual temperature by cell (annual_temp = mean(temp)) ## class : SpatRaster ## dimensions : 180, 180, 1 (nrow, ncol, nlyr) ## resolution : 0.008333333, 0.008333333 (x, y) ## extent : 5.5, 7, 49, 50.5 (xmin, xmax, ymin, ymax) ## coord. ref. : lon/lat WGS 84 (EPSG:4326) ## source(s) : memory ## name : mean ## min value : 6.541667 ## max value : 10.625000 3.2 Spatial Calculations All previous spatial calculation functionality is present. Many names have changed though as some functions have been split up into multiple functions and other functions have been collapsed into a single function. The motivation behind this is for the function names to be more descriptive in terms of what they are actually doing. The cellSize function always returns a spatRaster of areas. While projected raster cells should all have the same area, unprojected raster cells will vary spatially, depending on their distance from the equator. Old Functions New Function Operation area, rgeos::gArea expanse area covered area cellSize area of raster cell distance, pointDistance, distanceFromPoints distance distance between objects approxNA approximate Estimate values for NA cells in a raster 3.3 Local (*app) Functions In raster, there were a number of functions that behaved similar to the apply family of functions in base R, but had a variety of mostly unrelated names: calc, cellStats, overlay etc. In terra, these have been renamed, for the most part, with the *app suffix. A few options have been added as well. Old Functions New Function Operation calc app apply functions to the values of each raster cell stackApply tapp apply functions to cells grouped by layer overlay lapp apply functions to cells using layers as arguments rapp apply functions to a subset of layers that varies spatially sapp apply functions to layers, similar to sapply or lapply cellStats global apply functions to layers in a raster layerStats layerCor compute summary stats of layers pairwise movingFun roll compute function on a window moving through layers 3.4 Applying Deep Dive There are many apply-like functions in terra, but the most commonly used ones are app, tapp, lapp and global. The app and tapp functions work similarly to their base R pseudo-homophones apply and tapply. However, they apply the the function to all the cells in a spatRaster instead of all the rows or columns of a matrix/data.frame. For both app and tapp, the applied function should take a vector as its input. app outputs a single layer spatRaster, while tapp outputs a spatRaster with as many layers as there are unique values in the index vector. seasons = c(&#39;Winter&#39;, &#39;Winter&#39;, rep(&#39;Spring&#39;, 3), rep(&#39;Summer&#39;, 3), rep(&#39;Fall&#39;, 3), &#39;Winter&#39;) (seasonal_precip = tapp(precip, index=seasons, fun=&#39;mean&#39;)) ## class : SpatRaster ## dimensions : 180, 180, 4 (nrow, ncol, nlyr) ## resolution : 0.008333333, 0.008333333 (x, y) ## extent : 5.5, 7, 49, 50.5 (xmin, xmax, ymin, ymax) ## coord. ref. : lon/lat WGS 84 (EPSG:4326) ## source(s) : memory ## names : Winter, Spring, Summer, Fall ## min values : 53, 53.66667, 60.33333, 55.66667 ## max values : 127, 97.66667, 95.33333, 113.66667 lapp sounds like it should be the equivalent of lapply (“list apply”), but instead stands for “layer apply”. lapp applies a function that takes multiple values as inputs and applies it to each cell of a multilayer raster where each of the layers is used as an input. The output is a single layer spatRaster. One example of this is the NDVI (greenness) calculation for multi-spectral data. The global function is named as a contrast to zonal, focal and the local (*app) functions. global applies a function that outputs a single value to entire layers of data instead of to each cell. Its output is a data.frame with one column for each statistic passed to the function. For functions that take in an entire layer as input and also output an entire layer, you can use lapply, sapply or in rare cases sapp. #remove values not inside Luxembourg precip_lux = mask(precip, lux) # average and range of monthly precipitation for all of Luxembourg global(precip_lux, fun=c(&#39;mean&#39;,&#39;range&#39;), na.rm=TRUE) ## mean min max ## January 83.52010 62 107 ## February 65.39828 53 81 ## March 71.25246 57 90 ## April 58.10090 50 74 ## May 71.01005 65 80 ## June 71.84065 64 84 ## July 69.56030 60 84 ## August 58.92555 52 71 ## September 69.15033 61 83 ## October 79.10152 66 94 ## November 81.86710 67 102 ## December 93.68888 75 116 # calculating custom function (coefficient of variation) by month for all of # Luxembourg global(precip_lux, fun=cv, na.rm=TRUE) ## global ## January 0.14386729 ## February 0.09964252 ## March 0.11190306 ## April 0.08711527 ## May 0.03963299 ## June 0.05422691 ## July 0.06041096 ## August 0.05126035 ## September 0.05569626 ## October 0.07343647 ## November 0.09897658 ## December 0.10483384 "],["plotting.html", "4 Plotting 4.1 Static Plots 4.2 Interactive Plots", " 4 Plotting This section covers static and interactive plotting in terra. 4.1 Static Plots The look and feel of plotting in terra has not changed much from plotting in raster. It is still pretty straightforward, but not very feature rich. There are now convenience functions (below) so you don’t have to keep typing add=TRUE over and over again. And the y argument of terra::plot() allows you to specify which layers you want to plot, and in what order. #create outline of temp with luxembourg vector annual_temp_mask = mask(annual_temp, lux, touches=FALSE) plot(annual_temp_mask, y=1, col=temp_pal, box=FALSE, axes=FALSE, main=&#39;Annual Mean Temperature for Luxembourg (Celsius)&#39;) polys(lux, lwd=3) If you want to plot multiple layers with vector overlays, you will need to use the fun argument. This is a function that is applied to each of the layers in the plot. The function may have one argument which is the layer that is being plotted. In the code below, the backslash (\\) replaces the function call for brevity. Unfortunately I have yet to figure out how to include an overarching title on a plot that has multiple layers. #create outline of precip with luxembourg vector seasonal_precip_mask = mask(seasonal_precip, lux, touches=FALSE)[[c(2,3,4,1)]] #Plot Season precipitation (in mm) plot(seasonal_precip_mask, fun=\\() lines(lux), range=c(60, 100), loc.main=&quot;topright&quot;, col=precip_pal, axes=FALSE) To avoid duplicated legends, use panel() instead of plot(). Almost all the syntax is the same, but you can specify the number of rows (nr) and number of columns (nc) to use when plotting the raster layers. #Plot Season precipitation (in mm) panel(seasonal_precip_mask, fun=\\() lines(lux), loc.main=&quot;topright&quot;, col=precip_pal, axes=FALSE) 4.2 Interactive Plots Interactive plotting (with leaflet) is available in terra using the function plet. It requires leaflet version 2.1.1, which is now on CRAN, so installing from github is not necessary. To add vectors to the interactive plots you have to pipe (|&gt;) the interactive plot into a function that adds vector imagery to the plot (see below). To switch between layers of a multilayer interactive plot, click on the square in the upper right hand corner of the plot. if (packageVersion(&quot;leaflet&quot;) &lt;= &quot;2.1.1&quot;) { install.packages(&#39;leaflet&#39;) } plet(seasonal_precip_mask, y=1:4, col=precip_pal, shared=TRUE) |&gt; lines(lux, lwd=2) "],["whats-not-included.html", "5 What’s not included 5.1 Tidyverse compatability 5.2 Spatial Dependency and Regression 5.3 Where’s the data? geodata! 5.4 So about C++…", " 5 What’s not included While terra has a very large amount of functionality, it doesn’t have everything. This section covers functionality you will have to look elsewhere for. tidyverse integration spatial dependency and regression data downloading Native R classes 5.1 Tidyverse compatability The sf package is the preeminent package for working with vector data in R. It plays nicely with the tidyverse packages, and has built-in ggplot2 support. Sf supports wide to long spatial data transformations, something which definitely has more applicability for vector data than raster raster data. If you are tied to tidyverse syntax and plotting but also need terra speed, there is a package called tidyterra which can provide some of that functionality. Most notably tidyterra provides ggplot2 geom and autoplot methods for both spatRasters and spatVectors. However, it may make more sense to transition any spatVectors to simple features using the functions below if you want tidyverse integration. terra to sf: st_as_sf() sf to terra: vect() 5.1.1 What about rasters? The stars package provides tidyverse support for rasters. In general, it is not as well documented and does not provide as much user guidance as terra. Additionally, stars does not automatically handle data sets that are too large to to be read into memory. You have to know that your data set is too big and then make changes to your code detailed here. It does have some additional flexibility in terms of data types and grid schema, but these seem more like edge cases than something to change packages over. Stars also may be faster in some cases, but that depends on the task/function. There is a comparison between the two paradigms here, but unfortunately it uses raster instead of terra so a lot of the method names are wrong or missing. 5.2 Spatial Dependency and Regression The most commonly used packages for spatial dependency analysis and spatial regression (spdep and spatialreg) both use simple features objects (from sf). Thankfully the st_as_sf() function works very well for transitioning from spatVectors to simple features, and if you are only working with vector data you can probably forgo the spatVectors altogether. 5.3 Where’s the data? geodata! Another one of raster’s more useful features was getData(), a function that automated data downloading for a variety of online data sources. Unfortunately, getData() was poorly documented, to the point where using it required its own tutorial. In particular, because there was only one function for all of the data sources, it was always a guessing game as to which arguments were required for which data sources. It was even difficult to find a list of data sources available. It was not particularly well publicized either, to the point where people who used raster for years, did not know it existed. These problems have now been solved by migrating the functionality of getData to its own package: geodata. Every data source (listed below) has one or more functions, each of which is well documented. One notable change is that you must specify where the data should be downloaded. This can be done either in the function call itself or for a given R session using the function geodata_path. Marine data from Bio-ORACLE Current and future climate data from WorldClim Political boundaries and adminstrative data from GADM Elevation data from SRTM and GTOP30 at high latitudes Crop distribution and yield data from Monfreda et al. 2008, SPAM, ESA Worldcover, GLAD, and QED (for Africa) Crop calendars from Sacks et al. 2010 Landcover data from ESA Worldcover Last of the Wild Human Footprint map from NASA’s Socioeconomic Data and Applications Center (SEDAC) Open Street Map Human Population density from SEDAC Soils data from ISRIC, iSDA Species occurrence data from the Global Biodiversity Information Facility Travel times to cities and ports from Nelson et al. 2019 5.4 So about C++… As mentioned previously, spatRasters, spatVectors, and spatExtents (spat* objects) are all implemented in C++ instead of directly in R. This greatly improves processing speeds, as demonstrated above, but it does come with some costs. For most people, the only change will be that you can no longer recover spat* objects in from your workspace .RData files. This problem is easily solved by writing the data to a disk using writeRaster, which is considered best practices anyway. The other issue is only relevant to people who use computing clusters. Because of the way terra classes are implemented (using a C++ pointer), they cannot be passed directly to a computing cluster. They first need to be packaged up using the wrap function (documented here) which creates a Packed* version of the class. This can be transferred to the cluster and then converted back using unwrap. "],["resources.html", "6 Resources 6.1 Practice!", " 6 Resources For more in depth terra documentation, please see the resources below. Spatial Data with terra on rspatial.org - How to do spatial data analysis in the context of R and the terra package. terra documentation on rspatial.org - A vignette that walks you through the terra package. terra documentation on github - An overview of terra and a comprehensive description of its classes and methods. Highlights [differences][terra_diff] between raster and terra. geodata documentation on github - A description of available data as well as some links to the original source. 6.1 Practice! If you still feel a bit unsure about translating your own code from raster to terra syntax, you can test your skills using this raster practice script. A successfully transitioned terra script is also available on the github repo. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
